# Integrating musl libc with L4Re

## Overview

This whitepaper documents the transition of the L4ReRust project from its
legacy OSv-based glibc compatibility layer to a native integration of musl
libc. The goals of the migration are threefold:

1. Remove the dependency on OSv and the brittle downstream patches that were
   required to build and package its modified glibc sources.
2. Provide a lightweight, self-hosted C standard library that can be built and
   staged directly inside the L4ReRust tree for all supported architectures.
3. Ensure the new musl runtime is available to the L4Re build system, the L4Re
   kernel, Rust crates, and the boot images generated by the build pipeline.

The resulting integration keeps the workflow familiar for developers while
simplifying maintenance and enabling future musl-specific improvements.

## Build Pipeline Changes

### Source acquisition and staging

`build.sh` now orchestrates a dedicated `musl` component in place of the
previous `glibc` entry. When the component is selected, the build script
performs the following steps for each enabled architecture (currently `arm`
and `arm64`):

1. Download the official musl release archive (`musl-1.2.5`).
2. Apply any local patches located under `scripts/patches/musl` (the directory
   is optional and may be extended with L4Re specific adjustments in the
   future).
3. Invoke the new `scripts/build_musl.sh` helper that configures, builds, and
   installs musl into the architecture-specific staging prefix under
   `out/musl/<arch>`.

The helper performs an out-of-tree build, selecting the appropriate musl
configuration target (`arm-linux-musleabihf` or `aarch64-linux-musl`) while
respecting the configured cross compiler prefix. Both shared and static
variants of the C runtime are produced, and a minimal `musl.pc` pkg-config
file is generated for consumers that need to discover the staged libc through
pkg-config. Version markers (`VERSION`) are written to allow the incremental
component logic to determine whether a rebuild is required.

### Rust integration

The `l4re-libc` crate has been taught to discover musl instead of glibc.
`build.rs` now resolves `L4RE_LIBC_MUSL_PREFIX` (or its architecture-specific
variants) and links against the set of musl-provided libraries. The crate’s
link search path defaults to `out/musl/<arch>` when no override is supplied,
mirroring the previous behaviour while avoiding the old glibc assumptions.

A new smoke test (`musl_smoke.rs`) ensures the staged libc exports core
symbols such as `eventfd`, verifying that musl is correctly deployed and can be
loaded via `dlopen`/`dlsym`.

### Code reference across the repository

The integration spans several parts of the tree:

- `scripts/build.sh`: exposes the `musl` component, wires it into the shared
  component infrastructure, and primes the runtime environment via
  `prepare_rust_musl_environment` so Rust crates discover the staged runtime.
- `scripts/build_musl.sh`: performs the out-of-tree musl build using the
  architecture-specific cross compiler, installs headers and libraries into
  `out/musl/<arch>`, and emits a `musl.pc` pkg-config file.
- `pkg/musl/Makefile`: copies the staged headers, libraries, and pkg-config
  files into the layout expected by L4Re so the kernel can load the runtime.
- `crates/l4re-libc/build.rs`: discovers the staging prefix, adds the relevant
  link search paths, and ensures Rust code links against the musl libraries.
- `crates/l4re-libc/tests/musl_smoke.rs`: verifies that the staged libc exports
  critical symbols by loading the shared object at runtime.

### Packaging for L4Re

The packaging layer under `pkg/` has been updated with a `musl` package that
replaces the removed `glibc` package. The makefile copies headers, libraries,
and pkg-config files from the staging prefix into the temporary package staging
area used by the L4Re build system. The shared library staging helper in
`build.sh` recognises the musl component and installs the runtime pieces into
both the `config/lsb_root` root filesystem tree and the generated disk images.
All runtime consumers therefore continue to find loader binaries (e.g.
`ld-musl-aarch64.so.1`) and shared libraries under `/lib` and `/usr/lib`.

### Boot image inclusion

`build_lsb_root_component` now includes musl runtime files when assembling the
LSB root filesystem image. The logic explicitly gathers dynamic loaders and
key shared libraries so that the final bootable images produced from
`distribution/images` contain a complete musl runtime. The staging helper reuses
`pkg/musl` to ensure the files mirror the layout expected by the L4Re kernel
and userland.

## Kernel and System Integration

The L4Re kernel itself does not require source modifications to make use of
musl, but it must be able to locate the musl loader and runtime libraries at
boot. The module search paths generated by `setup.sh` remain unchanged because
musl is packaged into the existing L4Re package hierarchy. By staging musl’s
loader and shared libraries in the same locations previously occupied by the
OSv glibc artifacts, the kernel gains immediate access to the new runtime
without additional configuration.

Rust applications and ancillary components inherit the `LIBRARY_PATH` and
`LD_LIBRARY_PATH` adjustments performed by `prepare_rust_musl_environment`. The
environment exports `L4RE_LIBC_MUSL_PREFIX` variables so that downstream build
systems (including cargo build scripts, cmake projects, and pkg-config aware
consumers) can reference the musl prefix explicitly.

## Reproducing and Verifying the Integration

1. Run `scripts/build.sh --components musl` (or include `musl` in the default
   component selection) to populate `out/musl/<arch>` with the musl headers,
   libraries, loader, and pkg-config metadata for both ARM and ARM64.
2. Inspect the staged runtime under `out/musl/<arch>/lib` and confirm that the
   architecture-specific loader (for example `ld-musl-aarch64.so.1`) and shared
   libraries (`libc.so`, `libpthread.so`, `libdl.so`, and friends) are present.
3. The build script automatically propagates the staging prefix to cargo via
   `L4RE_LIBC_MUSL_PREFIX_<ARCH>`. To exercise the smoke test directly, run:

   ```bash
   L4RE_LIBC_MUSL_PREFIX_AARCH64=$PWD/out/musl/arm64 \
   cargo test -p l4re-libc --test musl_smoke --target aarch64-unknown-linux-musl
   ```

   Adjust the environment variable and target triple for ARM if desired. The
   test succeeds once the staged musl runtime is visible to the linker and
   exports the expected symbols.
4. Invoke `scripts/build.sh` with additional components (for example
   `--components musl,systemd,lsb_root`) to produce the bootable root
   filesystem. Inspect `config/lsb_root` or mount `out/images/lsb_root.img` to
   confirm that the musl loader and shared libraries have been copied into
   `/lib` and `/usr/lib`, ready for consumption by the L4Re kernel.

## Cleanup and Maintenance Benefits

Removing OSv integration eliminates a large amount of bespoke build logic and
patch maintenance. The repository no longer tracks third-party sources or
patches for OSv’s glibc fork. The musl integration relies solely on official
musl releases and the straightforward build helper, simplifying upgrades to
newer musl versions.

The new structure also encourages incremental enhancement: L4Re-specific musl
patches can be dropped into `scripts/patches/musl`, additional architectures can
be enabled by extending the component loop, and the pkg-config metadata can be
adapted as new consumers appear.

## Summary

By replacing OSv’s glibc compatibility layer with a native musl toolchain, the
L4ReRust project now provides a compact, maintainable libc foundation. The
integration spans the full stack—from component build orchestration through
Rust crate linkage and boot-image packaging—while keeping the developer
experience consistent with the previous workflow. Future work can focus on
extending musl-specific optimisations and tightening the integration with
L4Re services without the overhead of external dependencies.
