#!/usr/bin/env python3
"""
Dependency generator.

This utility inspects a binary for shared library dependencies.
It uses platform-specific tools:

- On Linux, `readelf -d` is invoked and `NEEDED` entries are parsed.
- On macOS (Darwin), `otool -L` is used and `.dylib` entries are collected.
"""
import os
import subprocess
import sys
from typing import List
import re


def _sanitize(name: str) -> str:
    """Sanitize dependency names for safe emission.

    Replaces unsupported characters with underscores and ensures the result
    does not begin with an underscore or other non-alphabetic character to
    avoid conflicts with system macros.
    """
    # Replace unsupported characters like periods or dashes with underscores.
    name = re.sub(r"[^0-9A-Za-z_]", "_", name)
    # Strip leading underscores.
    name = name.lstrip("_")
    # Prefix with 'dep_' if the name would otherwise start with a
    # non-alphabetic character.
    if not name or not name[0].isalpha():
        name = f"dep_{name}"
    return name


def _deps_from_readelf(path: str) -> List[str]:
    """Collect dependencies for ELF binaries using readelf.

    The dynamic section is scanned for `NEEDED` entries which denote shared
    libraries required at runtime.
    """
    output = subprocess.check_output(["readelf", "-d", path], text=True)
    deps: List[str] = []
    for line in output.splitlines():
        if "Shared library" in line:
            start = line.find("[")
            end = line.find("]", start)
            if start != -1 and end != -1:
                raw = line[start + 1 : end]
                deps.append(_sanitize(raw))
    return deps


def _deps_from_otool(path: str) -> List[str]:
    """Collect dependencies for Mach-O binaries using otool.

    `otool -L` lists libraries the binary depends on. Lines after the first
    contain library paths followed by version info. We keep entries that end
    with `.dylib` to match shared libraries on macOS.
    """
    output = subprocess.check_output(["otool", "-L", path], text=True)
    deps: List[str] = []
    for line in output.splitlines()[1:]:
        lib = line.strip().split(" ")[0]
        if lib.endswith(".dylib"):
            deps.append(_sanitize(os.path.basename(lib)))
    return deps


def main() -> int:
    if len(sys.argv) != 2:
        print(f"usage: {sys.argv[0]} <binary>")
        return 1
    binary = sys.argv[1]
    uname = os.uname().sysname
    if uname == "Darwin":
        deps = _deps_from_otool(binary)
    else:
        deps = _deps_from_readelf(binary)
    for dep in deps:
        print(dep)
    return 0


if __name__ == "__main__":
    sys.exit(main())
