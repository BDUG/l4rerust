diff --git a/meson.build b/meson.build
index a577ac7..1ccc854 100644
--- a/meson.build
+++ b/meson.build
@@ -1124,9 +1124,8 @@ else
         conf.set10('BPF_FRAMEWORK', deps_found)
 endif
 
-libmount = dependency('mount',
-                      version : fuzzer_build ? '>= 0' : '>= 2.30')
-
+conf.set10('HAVE_LIBMOUNT', false)
+libmount = declare_dependency()
 libfdisk = dependency('fdisk',
                       version : '>= 2.32',
                       disabler : true,
@@ -1957,7 +1956,6 @@ install_libsystemd_static = static_library(
                         libdl,
                         libgcrypt,
                         liblz4,
-                        libmount,
                         libopenssl,
                         librt,
                         libxz,
@@ -1996,8 +1994,7 @@ install_libudev_static = static_library(
         install_tag: 'libudev',
         install_dir : libdir,
         link_depends : libudev_sym,
-        dependencies : [libmount,
-                        libshared_deps,
+        dependencies : [libshared_deps,
                         userspace],
         c_args : static_libudev_pic ? [] : ['-fno-PIC'],
         pic : static_libudev_pic)
diff --git a/src/shared/libmount-util.h b/src/shared/libmount-util.h
index 2f789e7..8bbce23 100644
--- a/src/shared/libmount-util.h
+++ b/src/shared/libmount-util.h
@@ -1,11 +1,14 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 #pragma once
 
-/* This needs to be after sys/mount.h */
-#include <libmount.h>
+#include <stdio.h>
 
 #include "macro.h"
 
+#if HAVE_LIBMOUNT
+/* This needs to be after sys/mount.h */
+#include <libmount.h> /* IWYU pragma: export */
+
 DEFINE_TRIVIAL_CLEANUP_FUNC_FULL(struct libmnt_table*, mnt_free_table, NULL);
 DEFINE_TRIVIAL_CLEANUP_FUNC_FULL(struct libmnt_iter*, mnt_free_iter, NULL);
 
@@ -18,3 +21,146 @@ int libmount_parse(
 int libmount_is_leaf(
                 struct libmnt_table *table,
                 struct libmnt_fs *fs);
+#else
+#include <errno.h>
+
+struct libmnt_table;
+struct libmnt_iter;
+struct libmnt_fs;
+struct libmnt_monitor;
+
+static inline void mnt_free_table(struct libmnt_table *table) {
+        (void) table;
+}
+
+static inline void mnt_free_iter(struct libmnt_iter *iter) {
+        (void) iter;
+}
+
+DEFINE_TRIVIAL_CLEANUP_FUNC_FULL(struct libmnt_table*, mnt_free_table, NULL);
+DEFINE_TRIVIAL_CLEANUP_FUNC_FULL(struct libmnt_iter*, mnt_free_iter, NULL);
+
+static inline int libmount_parse(
+                const char *path,
+                FILE *source,
+                struct libmnt_table **ret_table,
+                struct libmnt_iter **ret_iter) {
+        (void) path;
+        (void) source;
+
+        if (ret_table)
+                *ret_table = NULL;
+        if (ret_iter)
+                *ret_iter = NULL;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+static inline int libmount_is_leaf(
+                struct libmnt_table *table,
+                struct libmnt_fs *fs) {
+        (void) table;
+        (void) fs;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+static inline int mnt_table_next_fs(
+                struct libmnt_table *table,
+                struct libmnt_iter *iter,
+                struct libmnt_fs **ret_fs) {
+        (void) table;
+        (void) iter;
+
+        if (ret_fs)
+                *ret_fs = NULL;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+static inline const char *mnt_fs_get_source(struct libmnt_fs *fs) {
+        (void) fs;
+
+        errno = EOPNOTSUPP;
+        return NULL;
+}
+
+static inline const char *mnt_fs_get_target(struct libmnt_fs *fs) {
+        (void) fs;
+
+        errno = EOPNOTSUPP;
+        return NULL;
+}
+
+static inline const char *mnt_fs_get_options(struct libmnt_fs *fs) {
+        (void) fs;
+
+        errno = EOPNOTSUPP;
+        return NULL;
+}
+
+static inline const char *mnt_fs_get_fstype(struct libmnt_fs *fs) {
+        (void) fs;
+
+        errno = EOPNOTSUPP;
+        return NULL;
+}
+
+static inline void mnt_init_debug(int mask) {
+        (void) mask;
+}
+
+static inline struct libmnt_monitor *mnt_new_monitor(void) {
+        errno = EOPNOTSUPP;
+        return NULL;
+}
+
+static inline void mnt_unref_monitor(struct libmnt_monitor *monitor) {
+        (void) monitor;
+}
+
+static inline int mnt_monitor_enable_kernel(struct libmnt_monitor *monitor, int enable) {
+        (void) monitor;
+        (void) enable;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+static inline int mnt_monitor_enable_userspace(
+                struct libmnt_monitor *monitor,
+                int enable,
+                const char *filename) {
+        (void) monitor;
+        (void) enable;
+        (void) filename;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+static inline int mnt_monitor_get_fd(struct libmnt_monitor *monitor) {
+        (void) monitor;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+static inline int mnt_monitor_next_change(
+                struct libmnt_monitor *monitor,
+                const char **filename,
+                int *type) {
+        (void) monitor;
+
+        if (filename)
+                *filename = NULL;
+        if (type)
+                *type = 0;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+#endif /* HAVE_LIBMOUNT */
diff --git a/src/shared/meson.build b/src/shared/meson.build
index b24a541..1f92b84 100644
--- a/src/shared/meson.build
+++ b/src/shared/meson.build
@@ -104,7 +104,6 @@ shared_sources = files(
         'label-util.c',
         'libcrypt-util.c',
         'libfido2-util.c',
-        'libmount-util.c',
         'local-addresses.c',
         'locale-setup.c',
         'logs-show.c',
@@ -117,8 +116,6 @@ shared_sources = files(
         'macvlan-util.c',
         'mkdir-label.c',
         'mkfs-util.c',
-        'mount-setup.c',
-        'mount-util.c',
         'net-condition.c',
         'netif-naming-scheme.c',
         'netif-sriov.c',
@@ -310,6 +307,16 @@ ethtool_link_mode_xml = custom_target(
         capture : true)
 man_page_depends += ethtool_link_mode_xml
 
+if conf.get('HAVE_LIBMOUNT') == 1
+        shared_sources += files(
+                'libmount-util.c',
+                'mount-setup.c',
+                'mount-util.c',
+        )
+else
+        shared_sources += files('mount-util-stub.c')
+endif
+
 libshared_name = 'systemd-shared-@0@'.format(shared_lib_tag)
 
 libshared_deps = [threads,
@@ -322,7 +329,6 @@ libshared_deps = [threads,
                   libiptc_cflags,
                   libkmod,
                   liblz4,
-                  libmount,
                   libopenssl,
                   libp11kit_cflags,
                   libpam,
diff --git a/src/test/meson.build b/src/test/meson.build
index cce90d7..d1b4e77 100644
--- a/src/test/meson.build
+++ b/src/test/meson.build
@@ -187,7 +187,6 @@ simple_tests += files(
 
 common_test_dependencies = [
         libblkid,
-        libmount,
         librt,
         libseccomp,
         libselinux,
@@ -307,13 +306,6 @@ executables += [
                 'dependencies' : libcrypt,
                 'timeout' : 120,
         },
-        test_template + {
-                'sources' : files('test-libmount.c'),
-                'dependencies' : [
-                        libmount,
-                        threads,
-                ],
-        },
         test_template + {
                 'sources' : files('test-loopback.c'),
                 'dependencies' : common_test_dependencies,
@@ -326,10 +318,6 @@ executables += [
                 'sources' : files('test-mempress.c'),
                 'dependencies' : threads,
         },
-        test_template + {
-                'sources' : files('test-mount-util.c'),
-                'dependencies' : libmount,
-        },
         test_template + {
                 'sources' : files('test-netlink-manual.c'),
                 'dependencies' : libkmod,
diff --git a/src/shared/mount-util-stub.c b/src/shared/mount-util-stub.c
new file mode 100644
index 0000000..d90e6d4
--- /dev/null
+++ b/src/shared/mount-util-stub.c
@@ -0,0 +1,332 @@
+#include <errno.h>
+
+#include "mount-util.h"
+#include "mount-setup.h"
+
+int repeat_unmount(const char *path, int flags) {
+        (void) path;
+        (void) flags;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int umount_recursive_full(const char *target, int flags, char **keep) {
+        (void) target;
+        (void) flags;
+        (void) keep;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int bind_remount_recursive_with_mountinfo(
+                const char *prefix,
+                unsigned long new_flags,
+                unsigned long flags_mask,
+                char **deny_list,
+                FILE *proc_self_mountinfo) {
+        (void) prefix;
+        (void) new_flags;
+        (void) flags_mask;
+        (void) deny_list;
+        (void) proc_self_mountinfo;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int bind_remount_one_with_mountinfo(
+                const char *path,
+                unsigned long new_flags,
+                unsigned long flags_mask,
+                FILE *proc_self_mountinfo) {
+        (void) path;
+        (void) new_flags;
+        (void) flags_mask;
+        (void) proc_self_mountinfo;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int mount_switch_root_full(const char *path, unsigned long mount_propagation_flag, bool force_ms_move) {
+        (void) path;
+        (void) mount_propagation_flag;
+        (void) force_ms_move;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int mount_verbose_full(
+                int error_log_level,
+                const char *what,
+                const char *where,
+                const char *type,
+                unsigned long flags,
+                const char *options,
+                bool follow_symlink) {
+        (void) error_log_level;
+        (void) what;
+        (void) where;
+        (void) type;
+        (void) flags;
+        (void) options;
+        (void) follow_symlink;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int umount_verbose(
+                int error_log_level,
+                const char *where,
+                int flags) {
+        (void) error_log_level;
+        (void) where;
+        (void) flags;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int mount_exchange_graceful(int fsmount_fd, const char *dest, bool mount_beneath) {
+        (void) fsmount_fd;
+        (void) dest;
+        (void) mount_beneath;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int mount_option_mangle(
+                const char *options,
+                unsigned long mount_flags,
+                unsigned long *ret_mount_flags,
+                char **ret_remaining_options) {
+        (void) options;
+        (void) mount_flags;
+
+        if (ret_mount_flags)
+                *ret_mount_flags = 0;
+        if (ret_remaining_options)
+                *ret_remaining_options = NULL;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int mode_to_inaccessible_node(const char *runtime_dir, mode_t mode, char **dest) {
+        (void) runtime_dir;
+        (void) mode;
+
+        if (dest)
+                *dest = NULL;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int mount_flags_to_string(unsigned long flags, char **ret) {
+        (void) flags;
+
+        if (ret)
+                *ret = NULL;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int bind_mount_in_namespace(
+                PidRef *target,
+                const char *propagate_path,
+                const char *incoming_path,
+                const char *src,
+                const char *dest,
+                bool read_only,
+                bool make_file_or_directory) {
+        (void) target;
+        (void) propagate_path;
+        (void) incoming_path;
+        (void) src;
+        (void) dest;
+        (void) read_only;
+        (void) make_file_or_directory;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int mount_image_in_namespace(
+                PidRef *target,
+                const char *propagate_path,
+                const char *incoming_path,
+                const char *src,
+                const char *dest,
+                bool read_only,
+                bool make_file_or_directory,
+                const MountOptions *options,
+                const ImagePolicy *image_policy) {
+        (void) target;
+        (void) propagate_path;
+        (void) incoming_path;
+        (void) src;
+        (void) dest;
+        (void) read_only;
+        (void) make_file_or_directory;
+        (void) options;
+        (void) image_policy;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int make_mount_point(const char *path) {
+        (void) path;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int fd_make_mount_point(int fd) {
+        (void) fd;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int make_userns(uid_t uid_shift, uid_t uid_range, uid_t owner, RemountIdmapping idmapping) {
+        (void) uid_shift;
+        (void) uid_range;
+        (void) owner;
+        (void) idmapping;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int remount_idmap_fd(char **p, int userns_fd) {
+        (void) userns_fd;
+
+        if (p)
+                *p = NULL;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int remount_idmap(char **p, uid_t uid_shift, uid_t uid_range, uid_t owner, RemountIdmapping idmapping) {
+        (void) uid_shift;
+        (void) uid_range;
+        (void) owner;
+        (void) idmapping;
+
+        if (p)
+                *p = NULL;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int bind_mount_submounts(
+                const char *source,
+                const char *target) {
+        (void) source;
+        (void) target;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int make_mount_point_inode_from_stat(const struct stat *st, const char *dest, mode_t mode) {
+        (void) st;
+        (void) dest;
+        (void) mode;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int make_mount_point_inode_from_path(const char *source, const char *dest, mode_t mode) {
+        (void) source;
+        (void) dest;
+        (void) mode;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int trigger_automount_at(int dir_fd, const char *path) {
+        (void) dir_fd;
+        (void) path;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+unsigned long credentials_fs_mount_flags(bool ro) {
+        (void) ro;
+
+        errno = EOPNOTSUPP;
+        return 0;
+}
+
+int mount_credentials_fs(const char *path, size_t size, bool ro) {
+        (void) path;
+        (void) size;
+        (void) ro;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int make_fsmount(
+                int error_log_level,
+                const char *what,
+                const char *type,
+                unsigned long flags,
+                const char *options,
+                int userns_fd) {
+        (void) error_log_level;
+        (void) what;
+        (void) type;
+        (void) flags;
+        (void) options;
+        (void) userns_fd;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int mount_setup_early(void) {
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int mount_setup(bool loaded_policy, bool leave_propagation) {
+        (void) loaded_policy;
+        (void) leave_propagation;
+
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+int mount_cgroup_controllers(void) {
+        errno = EOPNOTSUPP;
+        return -EOPNOTSUPP;
+}
+
+bool mount_point_is_api(const char *path) {
+        (void) path;
+
+        errno = EOPNOTSUPP;
+        return false;
+}
+
+bool mount_point_ignore(const char *path) {
+        (void) path;
+
+        errno = EOPNOTSUPP;
+        return false;
+}
